# **Java高并发**

## 相关概念

### 同步(Synchronous)与异步(Asynchronous)

同步和异步通常用来形容一次方法的调用。同步方法调用一旦开始，调用者必须等到调用返回后，才能执行后续行为。异步方法调用开始就会返回，调用者就可以继续执行后续的操作。

### 并发(Concurrency)与并行(Parallelism)

并发与并行非常容易被混淆，他们都表示两个或多个任务一起执行，但是各自的偏重点不同。并发偏重于多任务交替运行，而多个任务之间有可能还是串行的。而并行是正真意义上的“同时执行”。

### 临界区

临界区用来表示一种公共资源或者是共享数据，可以被多个线程使用，但是每一次，只能有一个线程使用它，一旦临界区资源被占用，其他线程想要使用这个资源，就必须等待。例如同一打印机同一时间只能打印一个文件。

### 阻塞(Blocking)与非阻塞(Non-Blocking)

阻塞和非阻塞通常用来形容线程之间的相互影响。比如一个线程占用了临界资源，那么其他所有需要的资源线程就必须在临界区中等待。等待会导致线程的挂起，这种情况就是阻塞。

非阻塞与阻塞意思相反，它强调没有一个线程可以妨碍其他线程执行。

### 死锁(Deadlock)、饥饿(Starvation)、活锁(Livelock)

死锁是指：

饥饿是指：某一或者多个线程因为种种原因而无法获取所需资源，一致处于无法执行状态。

活锁指：因互相的谦让而无法获取资源而导致的无法执行。

## 并发级别

### 阻塞(Blocking)

一个线程是阻塞的，那么在其他线程释放资源之前，当前线程无法继续执行。当我们所使用的synchronized关键字，或者重入锁，我们得到的就是阻塞的线程。

### 无饥饿(Starvation-Free)

线程之间如果有优先级，那么线程调度的时候总会倾向于满足高优先级的线程。这种非公平的锁可能导致低优先级线程产生饥饿。

### 无障碍(Obstruction-Free)

无障碍是一种最弱的费阻塞调度。它是一种乐观控制策略，默认为线程之间不会产生冲突，一旦产生冲突，则回滚。无障碍的实现可以依赖一个“一致性标记”来实现，先读取并保存这个标志，操作完成后进行比对，如果一致，则没有冲突。否则有冲突。

### 无锁(Lock-Free)

无锁的并行都是无障碍进行的。在无锁的情况下，所有线程都可以尝试对临界区进行访问，但不同的是，无锁的并发必须保证有一个线程能够在有限的步数内完成操作离开临界区。

### 无等待(Wait-Free)

无锁只要求有一个线程可以在有限步之内完成，而无等待则在无锁的基础之上更进一步扩展，要求所有的线程都在有限步之内完成，这样就不会引起饥饿问题。

## (Java内存模型)JMM

### 原子性(Atomicity)

指一个操作是不可中断的。即使是多个线程一起执行的时候，一个线程一旦开始，就不会被其他线程干扰。

### 可见性(Visibility)

指当一个线程修改了某一个共享变量的值，其他线程能够立即知道这个修改。对于串行程序来说，可见性问题不存在。

### 有序性(Ordering)

并发时，程序的执行可能会出现乱序，并非按照代码一样的顺序执行。

